# In-App Notifications PRD

## Executive Summary
Implement a real-time in-app notification system that displays message banners at the top of the screen and maintains accurate unread message counts on conversations, even when the user is actively viewing a conversation thread.

## Current State Analysis

### Existing Infrastructure
1. **NotificationService**: Handles iOS system notifications (UNUserNotificationCenter)
   - Suppresses notifications when `currentConversationId` matches message conversation
   - Shows banner + sound in foreground for other conversations
   
2. **Unread Count System**: Partially implemented
   - `ConversationEntity.unreadCount` field exists
   - Display logic in `ConversationRowView` works (shows blue badge)
   - `LocalStorageService` has increment/reset methods
   - **Issue**: Not being incremented when messages arrive

3. **Message Reception**: Two parallel paths
   - `ChatViewModel`: Real-time listener for active conversation
   - `ConversationListViewModel`: Fetches recent messages on updates

### Key Files
- Services: `NotificationService`, `MessageService`, `LocalStorageService`, `ReadReceiptService`
- ViewModels: `ChatViewModel`, `ConversationListViewModel`
- Views: `MainView`, `ChatView`, `ConversationListView`, `ConversationRowView`
- Models: `ConversationEntity`, `MessageEntity`

## Requirements

### 1. In-App Notification Banners
- **Display**: Banner appears at top of screen (below status bar)
- **Trigger**: Any incoming message from another user, regardless of current view
- **Content**: 
  - Sender name (or "Group: [name]" for groups)
  - Message preview (truncated if needed)
  - Avatar/icon
- **Behavior**:
  - Auto-dismiss after 3-4 seconds
  - Tap to navigate to conversation
  - Swipe to dismiss
  - Should appear even when user is viewing the conversation thread
- **Animation**: Slide down from top, slide up to dismiss

### 2. Unread Message Count Badges
- **Increment**: When message arrives from another user
- **Condition**: Only if user is NOT currently viewing that conversation
- **Reset**: When user opens/views the conversation (already implemented)
- **Display**: Blue badge with count on conversation row (already implemented)

### 3. Visual Feedback
- Conversation list should update immediately when new messages arrive
- Unread conversations should be visually distinct (bold text or indicator)

## Technical Approach

### Web Development Analogy (Vue + TypeScript)

Think of the solution like a Vue app:

1. **InAppNotificationService** = Vue composable with reactive state
   - Like `useNotifications()` composable
   - `@Published` properties = `ref()` in Vue
   - Manages queue of notifications to display

2. **NotificationBannerView** = Global Toast Component
   - Like `<Toast />` component in Vue overlaid at app root
   - Listens to notification service state
   - Similar to Vuetify's `v-snackbar` or custom toast component

3. **State Management** = Reactive Pattern
   - `@Published var notifications: [InAppNotification] = []` = `const notifications = ref<Notification[]>([])`
   - ObservableObject = Vue reactive object
   - Automatic UI updates when state changes

4. **Event Flow** = Pub/Sub Pattern
   - Message arrives → Service publishes → UI subscribes and displays
   - Similar to event bus or composable pattern in Vue

### Architecture Overview

```
┌─────────────────────────────────────────────────────────┐
│                    swift_demoApp                        │
│                        (Root)                           │
│  ┌────────────────────────────────────────────────┐   │
│  │              MainView                           │   │
│  │  ┌──────────────────────────────────────┐     │   │
│  │  │  NotificationBannerOverlay           │     │   │
│  │  │  (listens to InAppNotificationMgr)   │     │   │
│  │  └──────────────────────────────────────┘     │   │
│  │                                                 │   │
│  │  ┌──────────────────┬──────────────────┐     │   │
│  │  │ ConversationList │     ChatView     │     │   │
│  │  │                  │                   │     │   │
│  │  └──────────────────┴──────────────────┘     │   │
│  └────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
        ┌─────────────────────────────────────┐
        │   InAppNotificationManager          │
        │   (Observable, Singleton)           │
        │                                     │
        │   @Published notifications: []      │
        │                                     │
        │   + show(notification)              │
        │   + dismiss(id)                     │
        └─────────────────────────────────────┘
                           ▲
                           │
                    Called by ViewModels
                    when messages arrive
```

### Implementation Plan

#### Phase 1: Create In-App Notification Infrastructure

**1. Create InAppNotification Model**
```swift
struct InAppNotification: Identifiable {
    let id: String
    let conversationId: String
    let senderName: String
    let messageText: String
    let isGroup: Bool
    let timestamp: Date
}
```

**2. Create InAppNotificationManager Service**
```swift
class InAppNotificationManager: ObservableObject {
    @Published var currentNotification: InAppNotification?
    
    func show(notification: InAppNotification)
    func dismiss()
    // Auto-dismiss logic
}
```

**3. Create NotificationBannerView Component**
- SwiftUI view that displays at top of screen
- Reads from `InAppNotificationManager`
- Handles tap gesture (navigate to conversation)
- Handles swipe/auto-dismiss
- Animation: slide in from top

#### Phase 2: Integrate with Message Reception Flow

**4. Update ChatViewModel**
```swift
// In showNotificationForMessage:
- Keep existing system notification logic
- Add in-app notification for ALL incoming messages
- Check if user is viewing this conversation to determine unread increment
```

**5. Update ConversationListViewModel**
```swift
// In showNotificationForMessage:
- Add in-app notification call
- Increment unread count if user not viewing conversation
```

**6. Update MainView**
```swift
// Add notification banner overlay:
.overlay(alignment: .top) {
    NotificationBannerView()
        .environmentObject(InAppNotificationManager.shared)
}
```

#### Phase 3: Unread Count Logic

**7. Update Message Reception Logic**
```swift
// In both ChatViewModel and ConversationListViewModel:
when message arrives {
    if message.senderId != currentUserId {
        // Show in-app notification
        InAppNotificationManager.shared.show(...)
        
        // Increment unread count ONLY if not viewing this conversation
        if NotificationService.shared.currentConversationId != conversationId {
            try? await localStorage.incrementUnreadCount(conversationId)
        }
    }
}
```

**8. Ensure Read Receipt Integration**
```swift
// Already implemented in ChatView.onAppear:
viewModel.markMessagesAsRead()
// This calls ReadReceiptService which resets unreadCount
// ✓ No changes needed
```

#### Phase 4: UI Enhancements

**9. Update ConversationRowView (Optional)**
```swift
// Make unread conversations more prominent:
- Bold text for displayName if unreadCount > 0
- Different background color
```

### File Changes

#### New Files
1. **Models/InAppNotification.swift** - Notification data model
2. **Services/InAppNotificationManager.swift** - Notification state management
3. **Views/Components/NotificationBannerView.swift** - Banner UI component

#### Modified Files
1. **ViewModels/ChatViewModel.swift**
   - Update `showNotificationForMessage` to call InAppNotificationManager
   - Add unread count increment logic (with condition check)

2. **ViewModels/ConversationListViewModel.swift**
   - Update `showNotificationForMessage` to call InAppNotificationManager
   - Add unread count increment logic

3. **Views/MainView.swift**
   - Add NotificationBannerView overlay
   - Pass InAppNotificationManager as environment object

4. **swift_demoApp.swift**
   - Initialize InAppNotificationManager as @StateObject
   - Add to environment objects

5. **Views/Conversations/ConversationRowView.swift** (Optional)
   - Add bold text for unread conversations

### Notification Display Rules

| User Location | Incoming Message | System Notification | In-App Banner | Unread Count |
|---------------|------------------|---------------------|---------------|--------------|
| In conversation X | Message to X | ❌ Suppressed | ✅ Show | ❌ No increment |
| In conversation Y | Message to X | ✅ Show | ✅ Show | ✅ Increment |
| Conversation list | Message to X | ✅ Show | ✅ Show | ✅ Increment |
| Other screen | Message to X | ✅ Show | ✅ Show | ✅ Increment |

### Key Design Decisions

1. **Single Banner at a Time**: If multiple messages arrive quickly, show one at a time (queue)
   - Alternative: Stack banners (more complex)
   - Recommended: Simple queue with newest replacing current

2. **Banner Duration**: 3 seconds auto-dismiss
   - User can swipe to dismiss early
   - Tapping navigates to conversation

3. **Unread Count Logic**: Track by conversation
   - Increment: Message arrives AND user not viewing that conversation
   - Reset: User opens conversation (via markMessagesAsRead)
   - Persist in SwiftData (already implemented)

4. **Thread Safety**: All UI updates on MainActor
   - InAppNotificationManager uses MainActor
   - LocalStorageService already @MainActor

### Testing Checklist

1. **In-App Notifications**
   - [ ] Banner appears when message arrives in different conversation
   - [ ] Banner appears when message arrives in SAME conversation (key requirement)
   - [ ] Tap banner navigates to correct conversation
   - [ ] Swipe dismisses banner
   - [ ] Auto-dismiss after 3 seconds
   - [ ] Banner shows correct sender name and message preview
   - [ ] Group messages show "Group: [name]"

2. **Unread Counts**
   - [ ] Count increments when message arrives (user not in conversation)
   - [ ] Count does NOT increment when user is viewing conversation
   - [ ] Count resets when user opens conversation
   - [ ] Badge displays correctly on conversation row
   - [ ] Multiple messages increment count correctly
   - [ ] Count persists across app restarts

3. **Edge Cases**
   - [ ] Multiple rapid messages (queue handling)
   - [ ] Message arrives while app transitioning between views
   - [ ] Offline message sync doesn't trigger false notifications
   - [ ] Group messages with multiple participants
   - [ ] Long message text truncates properly in banner

### Implementation Notes

#### Like Web Development Patterns:

1. **Service Layer** (InAppNotificationManager)
   - Singleton pattern = like Vue app-level provide/inject
   - Observable = reactive state management
   - Methods = API/service functions

2. **Component Layer** (NotificationBannerView)
   - Reusable UI component
   - Props via environment object = like Vue props/inject
   - State-driven rendering = like Vue reactive templates

3. **Event Handling**
   - Message received → call service method
   - Service updates state → UI auto-updates
   - Similar to: API response → update store → UI rerenders

4. **Navigation**
   - Banner tap → post notification to NotificationCenter
   - MainView observes → updates navigation state
   - Like: event emit → router.push() in Vue

### Future Enhancements (Out of Scope)

1. External push notifications (APNs)
2. Notification sounds/haptics for in-app banners
3. Notification history/center
4. Rich notifications with images
5. Action buttons on notifications
6. Notification preferences/settings

## Success Metrics

- Users see in-app banners for ALL incoming messages (even in active conversation)
- Unread counts accurately reflect unviewed messages
- No false notifications from message sync operations
- Smooth animations and responsive interactions
- Zero crashes or state inconsistencies

## Timeline Estimate

- Phase 1 (Infrastructure): 2-3 hours
- Phase 2 (Integration): 2-3 hours  
- Phase 3 (Unread Logic): 1-2 hours
- Phase 4 (Polish): 1 hour
- Testing: 2-3 hours

**Total**: 8-12 hours of development + testing

---

## Appendix: Code Snippets

### InAppNotification Model
```swift
import Foundation

struct InAppNotification: Identifiable, Equatable {
    let id: String
    let conversationId: String
    let senderName: String
    let messageText: String
    let isGroup: Bool
    let timestamp: Date
    
    init(
        conversationId: String,
        senderName: String,
        messageText: String,
        isGroup: Bool
    ) {
        self.id = UUID().uuidString
        self.conversationId = conversationId
        self.senderName = senderName
        self.messageText = messageText
        self.isGroup = isGroup
        self.timestamp = Date()
    }
}
```

### InAppNotificationManager Service
```swift
import Foundation
import Combine

@MainActor
class InAppNotificationManager: ObservableObject {
    static let shared = InAppNotificationManager()
    
    @Published var currentNotification: InAppNotification?
    
    private var dismissTask: Task<Void, Never>?
    private let autoDismissDelay: TimeInterval = 3.0
    
    private init() {}
    
    func show(_ notification: InAppNotification) {
        // Cancel any existing auto-dismiss
        dismissTask?.cancel()
        
        // Show new notification
        currentNotification = notification
        
        // Auto-dismiss after delay
        dismissTask = Task { @MainActor in
            try? await Task.sleep(nanoseconds: UInt64(autoDismissDelay * 1_000_000_000))
            if !Task.isCancelled {
                self.dismiss()
            }
        }
    }
    
    func dismiss() {
        dismissTask?.cancel()
        withAnimation {
            currentNotification = nil
        }
    }
}
```

### NotificationBannerView Component
```swift
import SwiftUI

struct NotificationBannerView: View {
    @EnvironmentObject private var notificationManager: InAppNotificationManager
    
    var body: some View {
        if let notification = notificationManager.currentNotification {
            VStack {
                HStack(spacing: 12) {
                    // Avatar
                    Circle()
                        .fill(notification.isGroup ? Color.green : Color.blue)
                        .frame(width: 40, height: 40)
                        .overlay {
                            if notification.isGroup {
                                Image(systemName: "person.3.fill")
                                    .foregroundColor(.white)
                            } else {
                                Text(notification.senderName.prefix(1))
                                    .foregroundColor(.white)
                                    .font(.headline)
                            }
                        }
                    
                    // Content
                    VStack(alignment: .leading, spacing: 2) {
                        Text(notification.isGroup ? "Group: \(notification.senderName)" : notification.senderName)
                            .font(.subheadline)
                            .fontWeight(.semibold)
                        
                        Text(notification.messageText)
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .lineLimit(2)
                    }
                    
                    Spacer()
                }
                .padding()
                .background(
                    RoundedRectangle(cornerRadius: 12)
                        .fill(Color(.systemBackground))
                        .shadow(color: .black.opacity(0.1), radius: 8, y: 4)
                )
                .padding(.horizontal)
                .padding(.top, 8)
                
                Spacer()
            }
            .transition(.move(edge: .top).combined(with: .opacity))
            .onTapGesture {
                handleTap(notification: notification)
            }
            .gesture(
                DragGesture()
                    .onEnded { value in
                        if value.translation.height < -50 {
                            notificationManager.dismiss()
                        }
                    }
            )
        }
    }
    
    private func handleTap(notification: InAppNotification) {
        notificationManager.dismiss()
        
        // Navigate to conversation
        NotificationCenter.default.post(
            name: .navigateToConversation,
            object: nil,
            userInfo: ["conversationId": notification.conversationId]
        )
    }
}
```

### Integration in ChatViewModel
```swift
// In showNotificationForMessage method:
private func showNotificationForMessage(_ snapshot: MessageSnapshot) {
    // Get sender name
    let senderName: String
    if isGroup {
        senderName = participants.first { $0.id == snapshot.senderId }?.displayName ?? "Unknown"
    } else {
        senderName = participants.first?.displayName ?? recipientId
    }
    
    // Show system notification (existing logic - will be suppressed if in conversation)
    notificationService.showMessageNotification(
        conversationId: conversationId,
        senderName: senderName,
        messageText: snapshot.text,
        isGroup: isGroup
    )
    
    // ✨ NEW: Show in-app notification (always, even if in conversation)
    let inAppNotification = InAppNotification(
        conversationId: conversationId,
        senderName: senderName,
        messageText: snapshot.text,
        isGroup: isGroup
    )
    InAppNotificationManager.shared.show(inAppNotification)
    
    // ✨ NEW: Increment unread count ONLY if user not viewing this conversation
    if notificationService.currentConversationId != conversationId {
        Task {
            try? await localStorage.incrementUnreadCount(conversationId: conversationId)
        }
    }
}
```

---

**End of PRD**

